<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Aether | Generative Art Studio</title>
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Outfit:wght@200;300;400;500;600;700&family=Space+Mono:wght@400;700&display=swap" rel="stylesheet">
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css">
    <style>
        :root {
            --bg-dark: #050508;
            --bg-panel: rgba(20, 20, 25, 0.65);
            --primary: #7000ff;
            --primary-glow: rgba(112, 0, 255, 0.4);
            --accent: #00f3ff;
            --accent-glow: rgba(0, 243, 255, 0.4);
            --text-main: #ffffff;
            --text-muted: #8b9bb4;
            --border: rgba(255, 255, 255, 0.08);
            --glass-blur: blur(20px);
            --transition: all 0.4s cubic-bezier(0.16, 1, 0.3, 1);
            --font-main: 'Outfit', sans-serif;
            --font-mono: 'Space Mono', monospace;
        }

        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
            outline: none;
            -webkit-tap-highlight-color: transparent;
        }

        body {
            background-color: var(--bg-dark);
            color: var(--text-main);
            font-family: var(--font-main);
            overflow: hidden; /* Prevent scroll on desktop, handle in containers */
            height: 100vh;
            width: 100vw;
        }

        /* Animated Background Gradient */
        .ambient-bg {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: 
                radial-gradient(circle at 15% 50%, rgba(76, 29, 149, 0.15), transparent 40%),
                radial-gradient(circle at 85% 30%, rgba(56, 189, 248, 0.1), transparent 40%);
            z-index: -1;
            animation: pulse-bg 10s ease-in-out infinite alternate;
        }

        @keyframes pulse-bg {
            0% { opacity: 0.5; transform: scale(1); }
            100% { opacity: 0.8; transform: scale(1.1); }
        }

        /* Layout */
        .app-container {
            display: flex;
            height: 100vh;
            position: relative;
        }

        /* Canvas Area */
        .canvas-wrapper {
            flex: 1;
            position: relative;
            overflow: hidden;
            display: flex;
            align-items: center;
            justify-content: center;
            cursor: crosshair;
            background: radial-gradient(circle at center, #1a1a24 0%, #000000 100%);
            transition: var(--transition);
        }

        canvas {
            display: block;
            width: 100%;
            height: 100%;
        }

        /* Floating Header */
        .header-overlay {
            position: absolute;
            top: 2rem;
            left: 2rem;
            z-index: 10;
            pointer-events: none;
        }

        .header-content {
            background: rgba(0, 0, 0, 0.3);
            backdrop-filter: blur(10px);
            padding: 1rem 1.5rem;
            border-radius: 12px;
            border: 1px solid rgba(255, 255, 255, 0.05);
            display: inline-flex;
            flex-direction: column;
            gap: 0.25rem;
            pointer-events: auto;
            transform-origin: top left;
            transition: var(--transition);
        }

        .header-content:hover {
            background: rgba(0, 0, 0, 0.5);
            border-color: rgba(255, 255, 255, 0.1);
        }

        h1 {
            font-size: 1.5rem;
            font-weight: 700;
            letter-spacing: -0.02em;
            background: linear-gradient(135deg, #fff 0%, #a5b4fc 100%);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            text-shadow: 0 0 20px rgba(165, 180, 252, 0.3);
        }

        .tagline {
            font-size: 0.8rem;
            color: var(--text-muted);
            font-family: var(--font-mono);
        }

        /* Controls Sidebar */
        .controls-panel {
            width: 360px;
            background: var(--bg-panel);
            backdrop-filter: var(--glass-blur);
            -webkit-backdrop-filter: var(--glass-blur); /* Safari */
            border-left: 1px solid var(--border);
            display: flex;
            flex-direction: column;
            z-index: 20;
            transition: transform 0.4s cubic-bezier(0.16, 1, 0.3, 1);
            box-shadow: -10px 0 40px rgba(0,0,0,0.5);
        }

        .controls-panel.collapsed {
            transform: translateX(100%);
        }

        .panel-header {
            padding: 1.5rem;
            border-bottom: 1px solid var(--border);
            display: flex;
            justify-content: space-between;
            align-items: center;
        }

        .panel-title {
            font-size: 0.9rem;
            text-transform: uppercase;
            letter-spacing: 0.1em;
            color: var(--text-muted);
            font-weight: 600;
        }

        .panel-content {
            flex: 1;
            overflow-y: auto;
            padding: 1.5rem;
            display: flex;
            flex-direction: column;
            gap: 2rem;
        }

        .panel-content::-webkit-scrollbar {
            width: 6px;
        }
        .panel-content::-webkit-scrollbar-thumb {
            background: rgba(255,255,255,0.1);
            border-radius: 3px;
        }
        .panel-content::-webkit-scrollbar-track {
            background: transparent;
        }

        /* Sections */
        .control-section h3 {
            font-size: 0.85rem;
            color: var(--text-main);
            margin-bottom: 1rem;
            display: flex;
            align-items: center;
            gap: 0.5rem;
            font-weight: 500;
        }

        .control-section h3 i {
            color: var(--primary);
            font-size: 0.8rem;
        }

        /* Algorithm Grid */
        .algo-grid {
            display: grid;
            grid-template-columns: repeat(2, 1fr);
            gap: 0.75rem;
        }

        .algo-btn {
            background: rgba(255, 255, 255, 0.03);
            border: 1px solid var(--border);
            color: var(--text-muted);
            padding: 0.75rem;
            border-radius: 8px;
            cursor: pointer;
            transition: var(--transition);
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 0.5rem;
            font-size: 0.8rem;
            font-family: var(--font-main);
        }

        .algo-btn i {
            font-size: 1.25rem;
            margin-bottom: 0.25rem;
            transition: transform 0.3s ease;
        }

        .algo-btn:hover {
            background: rgba(255, 255, 255, 0.08);
            border-color: rgba(255, 255, 255, 0.2);
            color: var(--text-main);
            transform: translateY(-2px);
        }

        .algo-btn.active {
            background: rgba(112, 0, 255, 0.15);
            border-color: var(--primary);
            color: #fff;
            box-shadow: 0 0 20px rgba(112, 0, 255, 0.15);
        }

        .algo-btn.active i {
            color: var(--accent);
            transform: scale(1.1);
        }

        /* Sliders */
        .slider-group {
            margin-bottom: 1.25rem;
        }

        .slider-label {
            display: flex;
            justify-content: space-between;
            margin-bottom: 0.5rem;
            font-size: 0.85rem;
            color: var(--text-muted);
        }

        .slider-value {
            font-family: var(--font-mono);
            color: var(--accent);
            font-size: 0.8rem;
        }

        .range-input {
            width: 100%;
            -webkit-appearance: none;
            height: 4px;
            background: rgba(255, 255, 255, 0.1);
            border-radius: 2px;
            cursor: pointer;
            position: relative;
        }

        .range-input::-webkit-slider-thumb {
            -webkit-appearance: none;
            width: 16px;
            height: 16px;
            border-radius: 50%;
            background: var(--text-main);
            box-shadow: 0 0 10px rgba(255, 255, 255, 0.5);
            cursor: pointer;
            transition: transform 0.2s cubic-bezier(0.175, 0.885, 0.32, 1.275);
            margin-top: -6px; /* Center thumb */
        }

        .range-input::-webkit-slider-runnable-track {
            width: 100%;
            height: 4px;
            cursor: pointer;
            background: linear-gradient(to right, var(--primary) 0%, var(--primary) var(--value, 0%), rgba(255,255,255,0.1) var(--value, 0%), rgba(255,255,255,0.1) 100%);
            border-radius: 2px;
        }

        .range-input:hover::-webkit-slider-thumb {
            transform: scale(1.2);
            box-shadow: 0 0 15px rgba(255, 255, 255, 0.8);
        }

        /* Palette Swatches */
        .color-palettes {
            display: flex;
            gap: 0.5rem;
            flex-wrap: wrap;
        }

        .palette-btn {
            width: 32px;
            height: 32px;
            border-radius: 50%;
            border: 2px solid transparent;
            cursor: pointer;
            transition: var(--transition);
            position: relative;
        }

        .palette-btn:hover {
            transform: scale(1.1);
        }

        .palette-btn.active {
            border-color: var(--text-main);
            transform: scale(1.15);
            box-shadow: 0 0 15px rgba(0,0,0,0.5);
        }

        /* Action Buttons */
        .action-row {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 0.75rem;
            margin-top: auto;
        }

        .btn {
            padding: 0.8rem;
            border-radius: 8px;
            border: none;
            font-family: var(--font-main);
            font-weight: 600;
            font-size: 0.9rem;
            cursor: pointer;
            transition: var(--transition);
            display: flex;
            justify-content: center;
            align-items: center;
            gap: 0.5rem;
        }

        .btn-primary {
            background: linear-gradient(135deg, var(--primary), #4f46e5);
            color: #fff;
            box-shadow: 0 4px 15px var(--primary-glow);
        }

        .btn-primary:hover {
            transform: translateY(-2px);
            box-shadow: 0 8px 25px var(--primary-glow);
        }

        .btn-glass {
            background: rgba(255, 255, 255, 0.05);
            color: var(--text-main);
            border: 1px solid var(--border);
        }

        .btn-glass:hover {
            background: rgba(255, 255, 255, 0.1);
            border-color: rgba(255, 255, 255, 0.3);
        }

        /* Toggle Button for Mobile */
        .toggle-controls {
            position: absolute;
            top: 2rem;
            right: 2rem;
            width: 44px;
            height: 44px;
            border-radius: 12px;
            background: rgba(20, 20, 25, 0.8);
            backdrop-filter: blur(10px);
            border: 1px solid var(--border);
            color: #fff;
            display: flex;
            align-items: center;
            justify-content: center;
            cursor: pointer;
            z-index: 30;
            transition: var(--transition);
            display: none; /* Hidden on desktop by default unless we want a hide feature */
        }

        .toggle-controls:hover {
            background: var(--primary);
        }

        /* Stats */
        .stats-overlay {
            position: absolute;
            bottom: 2rem;
            left: 2rem;
            font-family: var(--font-mono);
            font-size: 0.75rem;
            color: rgba(255, 255, 255, 0.5);
            background: rgba(0,0,0,0.3);
            padding: 0.5rem 1rem;
            border-radius: 20px;
            backdrop-filter: blur(5px);
            pointer-events: none;
        }

        /* Responsiveness */
        @media (max-width: 1024px) {
            .controls-panel {
                width: 320px;
                position: absolute;
                right: 0;
                height: 100%;
            }
            
            .toggle-controls {
                display: flex;
            }

            .header-overlay {
                top: 1.5rem;
                left: 1.5rem;
            }
        }

        @media (max-width: 768px) {
            .controls-panel {
                width: 100%;
                transform: translateY(calc(100% - 60px)); /* Peak mode or fully hidden? Let's do off-screen */
                transform: translateY(0);
                position: absolute;
                bottom: 0px;
                height: 60vh;
                top: auto;
                right: 0;
                border-left: none;
                border-top: 1px solid var(--border);
                border-radius: 20px 20px 0 0;
            }

            .controls-panel.collapsed {
                transform: translateY(100%);
            }
            
            /* Add a drag handle behavior or similar if needed, but toggle button works */
            .toggle-controls {
                top: auto;
                bottom: 2rem;
                right: 2rem;
            }

            .header-content {
                padding: 0.75rem 1rem;
            }

            h1 { font-size: 1.2rem; }
            
            .app-container {
                flex-direction: column;
            }
        }
        
        /* Utility */
        .hidden { display: none !important; }
        .fade-in { animation: fadeIn 0.5s ease forwards; }
        
        @keyframes fadeIn {
            from { opacity: 0; transform: translateY(10px); }
            to { opacity: 1; transform: translateY(0); }
        }
    </style>
</head>
<body>
    <div class="ambient-bg"></div>

    <div class="app-container">
        <!-- Main Canvas -->
        <div class="canvas-wrapper" id="canvas-wrapper">
            <canvas id="artCanvas"></canvas>
            
            <!-- Header Overlay -->
            <div class="header-overlay fade-in">
                <div class="header-content">
                    <h1>AETHER</h1>
                    <div class="tagline">Interactive Generative Studio</div>
                </div>
            </div>

            <!-- Stats Overlay -->
            <div class="stats-overlay">
                FPS: <span id="fps-counter">60</span> | ENTITIES: <span id="entity-counter">0</span>
            </div>
        </div>

        <!-- Toggle Button -->
        <button class="toggle-controls" id="toggle-btn" aria-label="Toggle Controls">
            <i class="fas fa-sliders-h"></i>
        </button>

        <!-- Controls Side Panel -->
        <aside class="controls-panel" id="controls-panel">
            <div class="panel-header">
                <span class="panel-title">Configuration</span>
                <button class="btn-glass" style="padding: 5px 10px; border-radius: 6px;" id="close-panel-mobile"><i class="fas fa-chevron-down"></i></button>
            </div>
            
            <div class="panel-content">
                <!-- Algorithm Selector -->
                <div class="control-section">
                    <h3><i class="fas fa-layer-group"></i> Algorithm</h3>
                    <div class="algo-grid">
                        <button class="algo-btn active" data-algo="particles">
                            <i class="fas fa-atom"></i> Particles
                        </button>
                        <button class="algo-btn" data-algo="fractal">
                            <i class="fas fa-tree"></i> Fractal
                        </button>
                        <button class="algo-btn" data-algo="automata">
                            <i class="fas fa-border-all"></i> Automata
                        </button>
                        <button class="algo-btn" data-algo="flow">
                            <i class="fas fa-wind"></i> Flow Field
                        </button>
                        <button class="algo-btn" data-algo="voronoi">
                            <i class="fas fa-shapes"></i> Voronoi
                        </button>
                    </div>
                </div>

                <!-- Parameters -->
                <div class="control-section">
                    <h3><i class="fas fa-sliders"></i> Parameters</h3>
                    
                    <div class="slider-group">
                        <div class="slider-label">
                            <span>Density / Count</span>
                            <span class="slider-value" id="val-count">200</span>
                        </div>
                        <input type="range" class="range-input" id="inp-count" min="50" max="1500" step="10" value="200">
                    </div>

                    <div class="slider-group">
                        <div class="slider-label">
                            <span>Speed / Evolution</span>
                            <span class="slider-value" id="val-speed">1.0</span>
                        </div>
                        <input type="range" class="range-input" id="inp-speed" min="0" max="3" step="0.1" value="1.0">
                    </div>

                    <div class="slider-group">
                        <div class="slider-label">
                            <span>Chaos / Noise</span>
                            <span class="slider-value" id="val-chaos">0.5</span>
                        </div>
                        <input type="range" class="range-input" id="inp-chaos" min="0" max="1" step="0.01" value="0.5">
                    </div>

                    <div class="slider-group">
                        <div class="slider-label">
                            <span>Size / Scale</span>
                            <span class="slider-value" id="val-size">2.0</span>
                        </div>
                        <input type="range" class="range-input" id="inp-size" min="0.5" max="10" step="0.1" value="2.0">
                    </div>
                </div>

                <!-- Colors -->
                <div class="control-section">
                    <h3><i class="fas fa-palette"></i> Palette</h3>
                    <div class="color-palettes">
                        <button class="palette-btn active" style="background: linear-gradient(135deg, #00f3ff, #7000ff);" data-theme="cyber"></button>
                        <button class="palette-btn" style="background: linear-gradient(135deg, #FF9D6C, #BB4E75);" data-theme="sunset"></button>
                        <button class="palette-btn" style="background: linear-gradient(135deg, #00b09b, #96c93d);" data-theme="nature"></button>
                        <button class="palette-btn" style="background: linear-gradient(135deg, #8E2DE2, #4A00E0);" data-theme="royal"></button>
                        <button class="palette-btn" style="background: linear-gradient(135deg, #ff0000, #ffff00);" data-theme="fire"></button>
                    </div>
                </div>

                <!-- Actions -->
                <div class="action-row">
                    <button class="btn btn-glass" id="btn-reset">
                        <i class="fas fa-rotate-right"></i> Reset
                    </button>
                    <button class="btn btn-primary" id="btn-save">
                        <i class="fas fa-camera"></i> Save
                    </button>
                </div>
            </div>
        </aside>
    </div>

    <!-- Application Logic -->
    <script>
        /**
         * Core Utility & Configuration
         */
        const CONFIG = {
            width: 0,
            height: 0,
            pixelRatio: window.devicePixelRatio || 1,
            palettes: {
                cyber: ['#00f3ff', '#7000ff', '#ff00aa', '#ffffff'],
                sunset: ['#FF9D6C', '#BB4E75', '#633A82', '#FFE5D9'],
                nature: ['#00b09b', '#96c93d', '#f7ff00', '#dbf26e'],
                royal: ['#8E2DE2', '#4A00E0', '#00d2ff', '#e0c3fc'],
                fire: ['#ff9966', '#ff5e62', '#ff0000', '#ffd700']
            }
        };

        const STATE = {
            algo: 'particles',
            count: 200,
            speed: 1.0,
            chaos: 0.5,
            size: 2.0,
            theme: 'cyber',
            paused: false,
            pointer: { x: 0, y: 0, isDown: false, influence: 0 }
        };

        // UI References
        const canvas = document.getElementById('artCanvas');
        const ctx = canvas.getContext('2d', { alpha: false }); // Optimize for no transparency on base
        
        /**
         * Input Handling
         */
        function initInput() {
            const wrapper = document.getElementById('canvas-wrapper');
            
            const updatePointer = (x, y) => {
                const rect = canvas.getBoundingClientRect();
                STATE.pointer.x = x - rect.left;
                STATE.pointer.y = y - rect.top;
            };

            wrapper.addEventListener('mousemove', e => {
                updatePointer(e.clientX, e.clientY);
                // Smooth influence ramp up
                STATE.pointer.influence = Math.min(STATE.pointer.influence + 0.05, 1);
            });
            
            wrapper.addEventListener('mousedown', e => {
                STATE.pointer.isDown = true;
                if (currentSystem && currentSystem.onInteract) currentSystem.onInteract('down');
            });
            
            wrapper.addEventListener('mouseup', () => {
                STATE.pointer.isDown = false;
            });

            wrapper.addEventListener('mouseleave', () => {
                STATE.pointer.influence = 0;
            });
            
            // Touch support
            wrapper.addEventListener('touchmove', e => {
                e.preventDefault();
                updatePointer(e.touches[0].clientX, e.touches[0].clientY);
                STATE.pointer.influence = 1;
            }, { passive: false });
        }

        /**
         * System Base Class
         */
        class System {
            constructor() {
                this.entities = [];
            }
            init() {}
            update(dt) {}
            draw(ctx) {}
            resize() {}
            onInteract(type) {}
        }

        /**
         * Utils
         */
        const random = (min, max) => Math.random() * (max - min) + min;
        const randomColor = () => {
            const p = CONFIG.palettes[STATE.theme];
            return p[Math.floor(Math.random() * p.length)];
        };

        /**
         * 1. Particle System (Optimized with Object Pooling concept)
         */
        class ParticleSystem extends System {
            constructor() {
                super();
                this.pool = [];
            }

            init() {
                this.entities = [];
                for(let i=0; i < STATE.count; i++) {
                    this.spawn();
                }
            }

            spawn(x, y) {
                const p = this.pool.pop() || { x:0, y:0, vx:0, vy:0, size:0, color:'' };
                p.x = x || random(0, CONFIG.width);
                p.y = y || random(0, CONFIG.height);
                p.vx = random(-1, 1) * STATE.speed;
                p.vy = random(-1, 1) * STATE.speed;
                p.size = random(1, STATE.size * 2);
                p.color = randomColor();
                this.entities.push(p);
            }

            update(dt) {
                // Adjust count dynamically
                if (this.entities.length < STATE.count) this.spawn();
                if (this.entities.length > STATE.count) this.pool.push(this.entities.pop());

                for (let i = 0; i < this.entities.length; i++) {
                    const p = this.entities[i];
                    
                    // Mouse interaction
                    if (STATE.pointer.influence > 0) {
                        const dx = p.x - STATE.pointer.x;
                        const dy = p.y - STATE.pointer.y;
                        const dist = Math.sqrt(dx*dx + dy*dy);
                        if (dist < 200) {
                            const force = (200 - dist) / 200;
                            // Repel
                            p.vx += (dx / dist) * force * 0.5 * STATE.speed;
                            p.vy += (dy / dist) * force * 0.5 * STATE.speed;
                        }
                    }

                    p.x += p.vx * STATE.speed;
                    p.y += p.vy * STATE.speed;

                    // Deceleration
                    p.vx *= 0.99;
                    p.vy *= 0.99;

                    // Bounce
                    if (p.x < 0 || p.x > CONFIG.width) p.vx *= -1;
                    if (p.y < 0 || p.y > CONFIG.height) p.vy *= -1;
                    
                    // Keep in bounds hard clamp
                    p.x = Math.max(0, Math.min(CONFIG.width, p.x));
                    p.y = Math.max(0, Math.min(CONFIG.height, p.y));
                }
            }

            draw(ctx) {
                ctx.fillStyle = 'rgba(10, 10, 15, 0.2)'; // Trails
                ctx.fillRect(0, 0, CONFIG.width, CONFIG.height);

                ctx.globalCompositeOperation = 'lighter';
                
                // Draw connections
                ctx.beginPath();
                const connectDist = 100 * STATE.size * 0.5;
                
                for (let i = 0; i < this.entities.length; i++) {
                    const p = this.entities[i];
                    
                    // Draw particle
                    ctx.fillStyle = p.color;
                    ctx.beginPath();
                    ctx.arc(p.x, p.y, p.size, 0, Math.PI * 2);
                    ctx.fill();

                    // Optional connections (expensive, limit checks)
                    if (STATE.count < 300) {
                        for (let j = i + 1; j < this.entities.length; j++) {
                            const p2 = this.entities[j];
                            const dx = p.x - p2.x;
                            const dy = p.y - p2.y;
                            if (Math.abs(dx) > connectDist || Math.abs(dy) > connectDist) continue; // Fast reject
                            
                            const d2 = dx*dx + dy*dy;
                            if (d2 < connectDist * connectDist) {
                                ctx.strokeStyle = `rgba(255,255,255, ${0.1 * (1 - Math.sqrt(d2)/connectDist)})`;
                                ctx.beginPath();
                                ctx.moveTo(p.x, p.y);
                                ctx.lineTo(p2.x, p2.y);
                                ctx.stroke();
                            }
                        }
                    }
                }
                ctx.globalCompositeOperation = 'source-over';
            }

            onInteract(type) {
                if(type === 'down') {
                    for(let i=0; i<10; i++) this.spawn(STATE.pointer.x, STATE.pointer.y);
                }
            }
        }

        /**
         * 2. Fractal Tree (Recursive)
         */
        class FractalSystem extends System {
            constructor() {
                super();
                this.angleOffset = 0;
            }

            init() {
                // No per-frame entities, just draw
            }

            drawTree(x, y, len, angle, depth) {
                ctx.beginPath();
                ctx.save();
                ctx.translate(x, y);
                ctx.rotate(angle);
                
                // Styling
                ctx.strokeStyle = `hsl(${(depth * 20 + this.angleOffset * 50) % 360}, 70%, 60%)`;
                ctx.lineWidth = depth * 0.8 * (STATE.size/2);
                ctx.globalAlpha = 1;
                
                ctx.moveTo(0, 0);
                ctx.lineTo(0, -len);
                ctx.stroke();

                if (depth > 0) {
                    // Interactive param
                    const spread = (Math.PI / 4) * STATE.chaos + (Math.sin(Date.now() * 0.001 * STATE.speed) * 0.1);
                    const mult = 0.67;
                    
                    ctx.translate(0, -len);
                    
                    // Branch 1
                    ctx.save();
                    this.drawTree(0, 0, len * mult, spread, depth - 1);
                    ctx.restore();
                    
                    // Branch 2
                    ctx.save();
                    this.drawTree(0, 0, len * mult, -spread, depth - 1);
                    ctx.restore();
                }
                ctx.restore();
            }

            draw(ctx) {
                ctx.fillStyle = 'rgba(5, 5, 10, 0.5)'; // Fade effect
                ctx.fillRect(0, 0, CONFIG.width, CONFIG.height);
                
                this.angleOffset += 0.01 * STATE.speed;
                
                const trunkLen = 150 * (CONFIG.height / 800);
                const startDepth = Math.floor(STATE.count / 20) + 5; // Scale depth with count slider
                const clampedDepth = Math.min(startDepth, 12); // Prevent freeze
                
                // Root
                this.drawTree(CONFIG.width / 2, CONFIG.height, trunkLen, 0, clampedDepth);
            }
        }

        /**
         * 3. Flow Field (Perlin-ish Noise)
         */
        class FlowField extends System {
            init() {
                this.particles = [];
                for(let i=0; i<STATE.count * 2; i++) {
                    this.resetParticle({});
                }
                this.zOff = 0;
                
                // Clear fully
                ctx.fillStyle = '#000';
                ctx.fillRect(0,0, CONFIG.width, CONFIG.height);
            }
            
            resetParticle(p) {
                p.x = Math.random() * CONFIG.width;
                p.y = Math.random() * CONFIG.height;
                p.vx = 0;
                p.vy = 0;
                p.age = 0;
                p.maxAge = Math.random() * 200 + 100;
                p.color = randomColor();
                this.particles.push(p);
            }

            fakeNoise(x, y, z) {
                return Math.sin(x * 0.005 + z) * Math.cos(y * 0.005 + z) * Math.PI * 2;
            }

            update(dt) {
                this.zOff += 0.005 * STATE.speed;
                
                while(this.particles.length < STATE.count * 2) this.resetParticle({});
                if(this.particles.length > STATE.count * 2) this.particles.splice(0, this.particles.length - STATE.count * 2);

                for(let p of this.particles) {
                    const angle = this.fakeNoise(p.x, p.y, this.zOff);
                    
                    p.vx += Math.cos(angle) * 0.2;
                    p.vy += Math.sin(angle) * 0.2;
                    
                    // Mouse disturb
                    if (STATE.pointer.influence > 0) {
                        const dx = p.x - STATE.pointer.x;
                        const dy = p.y - STATE.pointer.y;
                        const d = Math.sqrt(dx*dx + dy*dy);
                        if (d < 150) {
                            p.vx += (dx/d) * 0.5;
                            p.vy += (dy/d) * 0.5;
                        }
                    }
                    
                    // Limit speed
                    const vel = Math.sqrt(p.vx*p.vx + p.vy*p.vy);
                    if (vel > 4) {
                        p.vx = (p.vx/vel) * 4;
                        p.vy = (p.vy/vel) * 4;
                    }

                    p.x += p.vx * STATE.speed;
                    p.y += p.vy * STATE.speed;
                    p.age++;

                    if (p.x < 0 || p.x > CONFIG.width || p.y < 0 || p.y > CONFIG.height || p.age > p.maxAge) {
                        // Respawn randomly
                        p.x = Math.random() * CONFIG.width;
                        p.y = Math.random() * CONFIG.height;
                        p.age = 0;
                        p.vx = 0; p.vy = 0;
                    }
                }
            }

            draw(ctx) {
                // Fade out slowly
                ctx.fillStyle = 'rgba(0, 0, 0, 0.05)';
                ctx.fillRect(0, 0, CONFIG.width, CONFIG.height);
                
                ctx.lineWidth = STATE.size;
                for(let p of this.particles) {
                    ctx.strokeStyle = p.color;
                    ctx.beginPath();
                    ctx.moveTo(p.x - p.vx, p.y - p.vy);
                    ctx.lineTo(p.x, p.y);
                    ctx.stroke();
                }
            }
        }

        /**
         * 4. Voronoi (Approximation optimized)
         * Using cone-draw method is cool but hard to perfect.
         * We'll use a brute-force on a low-res grid, then upscale.
         */
        class VoronoiSystem extends System {
            init() {
                this.points = [];
                // Limit points for performance
                for(let i=0; i<Math.min(STATE.count, 50); i++) {
                    this.points.push({
                        x: Math.random() * CONFIG.width,
                        y: Math.random() * CONFIG.height,
                        vx: (Math.random()-0.5)*2,
                        vy: (Math.random()-0.5)*2,
                        color: randomColor()
                    });
                }
                
                // Create offscreen canvas for low-res processing
                this.offCanvas = document.createElement('canvas');
                this.offCtx = this.offCanvas.getContext('2d');
                this.resize();
            }

            resize() {
                if(!this.offCanvas) return;
                // Render at 10% resolution for speed + nice blur effect
                this.scaleFactor = 0.15; // Higher = less blurry/blocky but slower
                this.offCanvas.width = CONFIG.width * this.scaleFactor;
                this.offCanvas.height = CONFIG.height * this.scaleFactor;
            }

            update(dt) {
                // Update points
                for(let p of this.points) {
                    p.x += p.vx * STATE.speed;
                    p.y += p.vy * STATE.speed;
                    
                    if(p.x < 0 || p.x > CONFIG.width) p.vx *= -1;
                    if(p.y < 0 || p.y > CONFIG.height) p.vy *= -1;
                    
                    // Keep in bounds
                    p.x = Math.max(0, Math.min(CONFIG.width, p.x));
                    p.y = Math.max(0, Math.min(CONFIG.height, p.y));
                }
                
                // Sync count roughly (if mismatched significantly)
                const target = Math.min(STATE.count, 60); // Cap at 60 for perf
                if (this.points.length < target) {
                    this.points.push({x: random(0,CONFIG.width), y:random(0,CONFIG.height), vx:random(-1,1), vy:random(-1,1), color:randomColor()});
                } else if(this.points.length > target) {
                    this.points.pop();
                }
            }

            draw(ctx) {
                const w = this.offCanvas.width;
                const h = this.offCanvas.height;
                const d = this.offCtx.createImageData(w, h);
                const scaledPoints = this.points.map(p => ({
                    x: p.x * this.scaleFactor,
                    y: p.y * this.scaleFactor,
                    r: parseInt(p.color.slice(1,3), 16),
                    g: parseInt(p.color.slice(3,5), 16),
                    b: parseInt(p.color.slice(5,7), 16)
                }));

                // Pixel processing
                for (let y = 0; y < h; y++) {
                    for (let x = 0; x < w; x++) {
                        let minDist = Infinity;
                        let closest = scaledPoints[0];
                        
                        // Optimized search
                        for (let i = 0; i < scaledPoints.length; i++) {
                            const p = scaledPoints[i];
                            const dx = x - p.x;
                            const dy = y - p.y;
                            const dist = dx*dx + dy*dy;
                            if (dist < minDist) {
                                minDist = dist;
                                closest = p;
                            }
                        }
                        
                        const idx = (y * w + x) * 4;
                        d.data[idx] = closest.r;
                        d.data[idx+1] = closest.g;
                        d.data[idx+2] = closest.b;
                        d.data[idx+3] = 255;
                    }
                }
                
                this.offCtx.putImageData(d, 0, 0);
                
                // Draw upscaled
                ctx.imageSmoothingEnabled = true; // Smooth out the blocks
                ctx.drawImage(this.offCanvas, 0, 0, CONFIG.width, CONFIG.height);
                
                // Draw seeds
                for(let p of this.points) {
                    ctx.beginPath();
                    ctx.arc(p.x, p.y, 4 * STATE.size, 0, Math.PI*2);
                    ctx.strokeStyle = '#fff';
                    ctx.lineWidth = 2;
                    ctx.stroke();
                }
            }
        }

        /**
         * 5. Automata (Conway's Game of Life)
         */
        class AutomataSystem extends System {
            init() {
                this.cellSize = 10;
                this.cols = Math.ceil(CONFIG.width / this.cellSize);
                this.rows = Math.ceil(CONFIG.height / this.cellSize);
                this.grid = new Uint8Array(this.cols * this.rows);
                this.buffer = new Uint8Array(this.cols * this.rows); // Secondary buffer
                
                // Randomize
                for(let i=0; i<this.grid.length; i++) {
                    this.grid[i] = Math.random() > (1 - STATE.chaos * 0.5) ? 1 : 0;
                }
                
                this.tick = 0;
            }

            resize() {
                this.init(); // Re-init on resize simple
            }

            update(dt) {
                if (this.tick++ % Math.max(1, Math.floor(5 - STATE.speed)) !== 0) return;

                // Game of Logic
                for (let y = 0; y < this.rows; y++) {
                    for (let x = 0; x < this.cols; x++) {
                        const idx = y * this.cols + x;
                        
                        // Count neighbors
                        let neighbors = 0;
                        for (let dy = -1; dy <= 1; dy++) {
                            for (let dx = -1; dx <= 1; dx++) {
                                if (dx === 0 && dy === 0) continue;
                                const nx = (x + dx + this.cols) % this.cols;
                                const ny = (y + dy + this.rows) % this.rows;
                                neighbors += this.grid[ny * this.cols + nx];
                            }
                        }
                        
                        const cell = this.grid[idx];
                        if (cell === 1 && (neighbors < 2 || neighbors > 3)) {
                            this.buffer[idx] = 0;
                        } else if (cell === 0 && neighbors === 3) {
                            this.buffer[idx] = 1;
                        } else {
                            this.buffer[idx] = cell;
                        }
                    }
                }
                
                // Interact - paint
                if(STATE.pointer.isDown) {
                    const gx = Math.floor(STATE.pointer.x / this.cellSize);
                    const gy = Math.floor(STATE.pointer.y / this.cellSize);
                    if(gx>=0 && gx<this.cols && gy>=0 && gy<this.rows) {
                         this.buffer[gy * this.cols + gx] = 1;
                         // Brush
                         if(gx+1<this.cols) this.buffer[gy * this.cols + gx + 1] = 1;
                         if(gy+1<this.rows) this.buffer[(gy+1) * this.cols + gx] = 1;
                    }
                }

                // Swap
                [this.grid, this.buffer] = [this.buffer, this.grid];
            }

            draw(ctx) {
                ctx.fillStyle = 'rgba(0,0,0,0.2)'; // Trail
                ctx.fillRect(0,0, CONFIG.width, CONFIG.height);
                
                const p = CONFIG.palettes[STATE.theme];
                const colorAlive = p[1];
                
                ctx.fillStyle = colorAlive;
                for (let y = 0; y < this.rows; y++) {
                    for (let x = 0; x < this.cols; x++) {
                        if (this.grid[y * this.cols + x]) {
                            ctx.fillRect(x * this.cellSize, y * this.cellSize, this.cellSize - 1, this.cellSize - 1);
                        }
                    }
                }
            }
        }

        /**
         * Main Engine
         */
        let currentSystem = null;
        const systems = {
            particles: new ParticleSystem(),
            fractal: new FractalSystem(),
            flow: new FlowField(),
            voronoi: new VoronoiSystem(),
            automata: new AutomataSystem()
        };

        function switchAlgo(name) {
            STATE.algo = name;
            currentSystem = systems[name];
            
            // UI Update
            document.querySelectorAll('.algo-btn').forEach(b => {
                b.classList.toggle('active', b.dataset.algo === name);
            });
            
            // Re-init
            handleResize(); // Ensures sizes are correct
            currentSystem.init();
        }

        function handleResize() {
            const container = document.getElementById('canvas-wrapper');
            CONFIG.width = container.clientWidth;
            CONFIG.height = container.clientHeight;
            
            canvas.width = CONFIG.width;
            canvas.height = CONFIG.height;
            
            if(currentSystem) currentSystem.resize();
        }

        // Loop
        let lastTime = 0;
        let frames = 0;
        let lastFpsTime = 0;

        function loop(timestamp) {
            const dt = timestamp - lastTime;
            lastTime = timestamp;

            if (!STATE.paused && currentSystem) {
                currentSystem.update(dt);
                currentSystem.draw(ctx);
                
                // Update Entity Counter
                const count = currentSystem.entities ? currentSystem.entities.length : 
                              (STATE.algo === 'voronoi' ? currentSystem.points.length : 'N/A');
                document.getElementById('entity-counter').innerText = count;
            }

            // FPS
            frames++;
            if (timestamp - lastFpsTime >= 1000) {
                document.getElementById('fps-counter').innerText = frames;
                frames = 0;
                lastFpsTime = timestamp;
            }

            requestAnimationFrame(loop);
        }

        /**
         * Startup & Events
         */
        window.addEventListener('load', () => {
            initInput();
            handleResize();
            switchAlgo('particles'); // Default
            requestAnimationFrame(loop);
            
            // UI Bindings
            window.addEventListener('resize', handleResize);
            
            // Toggle config
            const panel = document.getElementById('controls-panel');
            const toggle = document.getElementById('toggle-btn');
            const close = document.getElementById('close-panel-mobile');
            
            toggle.addEventListener('click', () => panel.classList.toggle('collapsed'));
            close.addEventListener('click', () => panel.classList.add('collapsed'));

            // Algo Buttons
            document.querySelectorAll('.algo-btn').forEach(btn => {
                btn.addEventListener('click', () => switchAlgo(btn.dataset.algo));
            });

            // Sliders
            const bindSlider = (id, key, displayId) => {
                const el = document.getElementById(id);
                const disp = document.getElementById(displayId);
                el.addEventListener('input', e => {
                    let val = parseFloat(e.target.value);
                    STATE[key] = val;
                    disp.innerText = val;
                    
                    // Update CSS var for slider fill
                    const percent = ((val - el.min) / (el.max - el.min)) * 100;
                    el.style.setProperty('--value', percent + '%');
                });
                
                // Init fill
                const percent = ((el.value - el.min) / (el.max - el.min)) * 100;
                el.style.setProperty('--value', percent + '%');
            };

            bindSlider('inp-count', 'count', 'val-count');
            bindSlider('inp-speed', 'speed', 'val-speed');
            bindSlider('inp-chaos', 'chaos', 'val-chaos');
            bindSlider('inp-size', 'size', 'val-size');

            // Themes
            document.querySelectorAll('.palette-btn').forEach(btn => {
                btn.addEventListener('click', () => {
                    STATE.theme = btn.dataset.theme;
                    document.querySelectorAll('.palette-btn').forEach(b => b.classList.remove('active'));
                    btn.classList.add('active');
                    if(STATE.algo === 'flow' || STATE.algo === 'particles') currentSystem.init(); // Refresh for colors
                });
            });

            // Actions
            document.getElementById('btn-reset').addEventListener('click', () => {
                ctx.clearRect(0,0,CONFIG.width, CONFIG.height);
                currentSystem.init();
            });

            document.getElementById('btn-save').addEventListener('click', () => {
                const link = document.createElement('a');
                link.download = `Aether-${Date.now()}.png`;
                link.href = canvas.toDataURL();
                link.click();
            });
        });

    </script>
</body>
</html>