<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Bubble Bounce | Pro Edition</title>
    <!-- Google Fonts -->
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Orbitron:wght@400;700;900&family=Outfit:wght@300;400;600&display=swap" rel="stylesheet">
    <style>
        :root {
            --primary: #00f2ff;
            --secondary: #bd00ff;
            --accent: #fff;
            --bg-dark: #050510;
            --glass: rgba(15, 15, 30, 0.65);
            --glass-border: rgba(255, 255, 255, 0.1);
        }

        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
            user-select: none;
            -webkit-user-select: none;
            touch-action: none; /* Prevent browser zooming/scrolling */
        }

        body {
            background-color: var(--bg-dark);
            background-image: 
                radial-gradient(circle at 10% 20%, rgba(0, 242, 255, 0.15) 0%, transparent 40%),
                radial-gradient(circle at 90% 80%, rgba(189, 0, 255, 0.15) 0%, transparent 40%),
                linear-gradient(to bottom, #02020a, #0a0a1a);
            min-height: 100vh;
            display: flex;
            justify-content: center;
            align-items: center;
            font-family: 'Outfit', sans-serif;
            overflow: hidden;
            color: white;
        }

        .game-container {
            width: 100%;
            max-width: 900px;
            /* Aspect ratio is handled by height calculation or flex, 
               but we use flex column to fill. 
               We will let JS and internal Canvas aspect ratio logic handle the game view. 
               The container just holds the UI and Canvas. */
            height: clamp(500px, 90vh, 800px);
            aspect-ratio: 16/10;
            
            background: var(--glass);
            border: 1px solid var(--glass-border);
            backdrop-filter: blur(16px);
            -webkit-backdrop-filter: blur(16px);
            border-radius: 24px;
            box-shadow: 
                0 0 40px rgba(0, 242, 255, 0.05),
                0 20px 50px rgba(0, 0, 0, 0.5),
                inset 0 0 0 1px rgba(255, 255, 255, 0.05);
            position: relative;
            display: flex;
            flex-direction: column;
            overflow: hidden;
            transition: all 0.3s ease;
        }

        /* Stats Bar */
        .header {
            padding: 15px 30px;
            background: rgba(0, 0, 0, 0.3);
            display: flex;
            justify-content: space-between;
            align-items: center;
            border-bottom: 1px solid var(--glass-border);
            z-index: 20;
            flex-shrink: 0;
        }

        .stats {
            display: flex;
            gap: 40px;
        }

        .stat {
            display: flex;
            flex-direction: column;
            align-items: center;
        }

        .stat-value {
            font-family: 'Orbitron', sans-serif;
            font-size: 1.5rem;
            font-weight: 700;
            color: var(--primary);
            text-shadow: 0 0 10px rgba(0, 242, 255, 0.4);
        }

        .stat-label {
            font-size: 0.75rem;
            letter-spacing: 2px;
            color: rgba(255, 255, 255, 0.6);
            margin-top: 2px;
        }

        /* Buttons */
        .controls {
            display: flex;
            gap: 12px;
        }

        button {
            background: rgba(255, 255, 255, 0.05);
            color: white;
            border: 1px solid rgba(255, 255, 255, 0.1);
            padding: 8px 20px;
            border-radius: 50px;
            cursor: pointer;
            font-family: 'Orbitron', sans-serif;
            font-size: 0.8rem;
            letter-spacing: 1px;
            transition: all 0.3s cubic-bezier(0.25, 0.8, 0.25, 1);
            backdrop-filter: blur(4px);
        }

        button:hover {
            background: var(--primary);
            color: #000;
            box-shadow: 0 0 20px rgba(0, 242, 255, 0.4);
            transform: translateY(-2px);
            border-color: transparent;
        }

        button:active {
            transform: translateY(0);
        }

        /* Game Area */
        .game-area {
            flex: 1;
            position: relative;
            overflow: hidden;
            background: rgba(0,0,0,0.2);
            cursor: none;
            width: 100%;
        }

        #gameCanvas {
            display: block;
            width: 100%;
            height: 100%;
        }

        /* Overlays / Screens */
        .screen {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            background: rgba(5, 5, 16, 0.85);
            backdrop-filter: blur(10px);
            z-index: 10;
            padding: 20px;
            text-align: center;
            transition: opacity 0.4s ease;
        }

        .hidden {
            opacity: 0;
            pointer-events: none;
            visibility: hidden;
        }

        h1 {
            font-family: 'Orbitron', sans-serif;
            font-size: 4rem;
            text-transform: uppercase;
            margin-bottom: 20px;
            background: linear-gradient(to right, var(--primary), #fff, var(--secondary));
            background-clip: text;
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            text-shadow: 0 0 30px rgba(0, 242, 255, 0.3);
            letter-spacing: -2px;
        }

        h2 {
            font-family: 'Orbitron', sans-serif;
            font-size: 2.5rem;
            margin-bottom: 15px;
            color: #fff;
            text-shadow: 0 0 15px var(--secondary);
        }

        p {
            font-size: 1.1rem;
            margin-bottom: 30px;
            max-width: 600px;
            line-height: 1.6;
            color: rgba(255,255,255,0.8);
        }

        /* Screen Elements */
        .bubble-showcase {
            display: flex;
            gap: 20px;
            margin: 30px 0;
        }

        .showcase-item {
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 10px;
            font-size: 0.8rem;
            color: rgba(255,255,255,0.6);
        }

        .showcase-bubble {
            width: 40px;
            height: 40px;
            border-radius: 50%;
            box-shadow: inset -5px -5px 10px rgba(0,0,0,0.3);
        }

        .level-grid {
            display: grid;
            grid-template-columns: repeat(3, 1fr);
            gap: 20px;
            margin: 30px 0;
        }

        .level-btn {
            width: 80px;
            height: 80px;
            border-radius: 20px;
            background: rgba(255, 255, 255, 0.05);
            border: 1px solid rgba(255, 255, 255, 0.1);
            font-family: 'Orbitron', sans-serif;
            font-size: 1.5rem;
            display: flex;
            justify-content: center;
            align-items: center;
            transition: all 0.3s ease;
        }

        .level-btn:hover {
            background: var(--secondary);
            transform: scale(1.1) rotate(5deg);
            box-shadow: 0 0 25px rgba(189, 0, 255, 0.5);
        }

        .action-btn {
            padding: 12px 40px;
            font-size: 1.2rem;
            background: var(--primary);
            color: #000;
            border: none;
            box-shadow: 0 0 20px rgba(0, 242, 255, 0.4);
            font-weight: 700;
        }
        
        .action-btn:hover {
            transform: scale(1.05);
            box-shadow: 0 0 40px rgba(0, 242, 255, 0.6);
        }

        .input-group {
            margin: 20px 0;
            display: flex;
            gap: 10px;
            justify-content: center;
        }

        input {
            padding: 12px 20px;
            border-radius: 50px;
            border: 1px solid rgba(255, 255, 255, 0.2);
            background: rgba(0, 0, 0, 0.4);
            color: white;
            font-family: 'Outfit', sans-serif;
            text-align: center;
            outline: none;
            transition: border-color 0.3s;
        }

        input:focus {
            border-color: var(--primary);
            box-shadow: 0 0 15px rgba(0, 242, 255, 0.2);
        }

        .score-list {
            list-style: none;
            width: 100%;
            max-width: 400px;
            margin: 20px auto;
            background: rgba(255,255,255,0.03);
            border-radius: 12px;
            padding: 10px;
        }

        .score-list li {
            padding: 12px 20px;
            border-bottom: 1px solid rgba(255,255,255,0.05);
            display: flex;
            justify-content: space-between;
            font-family: 'Orbitron', sans-serif;
        }

        .score-list li:last-child { border-bottom: none; }
        .score-list li span:last-child { color: var(--primary); }

        .footer {
            padding: 12px;
            text-align: center;
            background: rgba(0, 0, 0, 0.4);
            border-top: 1px solid var(--glass-border);
            font-size: 0.85rem;
            color: rgba(255,255,255,0.4);
            flex-shrink: 0;
        }

        /* Mobile Adjustments */
        @media (max-width: 768px) {
            .game-container {
                width: 100vw;
                height: 100vh;
                max-width: none;
                border-radius: 0;
                border: none;
                aspect-ratio: auto;
            }
            h1 { font-size: 2.5rem; }
            .stats { gap: 15px; }
            .controls button span { display: none; } /* Hide text if we had span, otherwise standard */
            .controls button { padding: 8px 12px; font-size: 0.7rem; }
            .header { padding: 10px 15px; }
            .game-area { border-radius: 0; }
        }
    </style>
</head>
<body>
    <div class="game-container">
        <!-- Header / Stats -->
        <div class="header">
            <div class="stats">
                <div class="stat">
                    <div class="stat-value" id="score">0</div>
                    <div class="stat-label">SCORE</div>
                </div>
                <div class="stat">
                    <div class="stat-value" id="level">1</div>
                    <div class="stat-label">LEVEL</div>
                </div>
                <div class="stat">
                    <div class="stat-value" id="lives">3</div>
                    <div class="stat-label">LIVES</div>
                </div>
            </div>
            <div class="controls">
                <button id="toggleSoundBtn">SOUND: ON</button>
                <button id="pauseBtn">PAUSE</button>
            </div>
        </div>
        
        <!-- Game Area -->
        <div class="game-area">
            <canvas id="gameCanvas"></canvas>
            
            <!-- Start Screen -->
            <div id="startScreen" class="screen">
                <h1>Bubble Bounce</h1>
                <p>Destroy all neon orbs. Catch power-ups. Keep the ball alive.</p>
                
                <div class="bubble-showcase">
                    <div class="showcase-item">
                        <div class="showcase-bubble" style="background: linear-gradient(135deg, #ff5252, #d50000);"></div>
                        <span>Normal</span>
                    </div>
                    <div class="showcase-item">
                        <div class="showcase-bubble" style="background: linear-gradient(135deg, #ffd740, #ffab00);"></div>
                        <span>Tough</span>
                    </div>
                    <div class="showcase-item">
                        <div class="showcase-bubble" style="background: linear-gradient(135deg, #bd00ff, #7c4dff);"></div>
                        <span>Epic</span>
                    </div>
                </div>
                
                <button id="startBtn" class="action-btn">INITIALIZE</button>
            </div>
            
            <!-- Level Select Screen -->
            <div id="levelSelectScreen" class="screen hidden">
                <h2>Select Zone</h2>
                <div class="level-grid">
                    <button class="level-btn" data-level="1" style="color:#ff5252; border-color:#ff5252;">1</button>
                    <button class="level-btn" data-level="2" style="color:#ffd740; border-color:#ffd740;">2</button>
                    <button class="level-btn" data-level="3" style="color:#00f2ff; border-color:#00f2ff;">3</button>
                </div>
                <button id="backToStartBtn">BACK</button>
            </div>
            
            <!-- Game Over Screen -->
            <div id="gameOverScreen" class="screen hidden">
                <h2 id="gameOverTitle">MISSION FAILED</h2>
                <p>Final Score: <span id="finalScore" style="color:var(--primary); font-weight:bold; font-size:1.4rem;">0</span></p>
                
                <div class="input-group">
                    <input type="text" id="playerName" placeholder="Enter Pilot Name" maxlength="10">
                    <button id="saveScoreBtn">SAVE</button>
                </div>

                <ul class="score-list" id="scoreList"></ul>
                
                <div class="controls" style="justify-content:center; margin-top:20px;">
                    <button id="restartBtn" class="action-btn">RETRY</button>
                    <button id="menuBtn">MENU</button>
                </div>
            </div>
            
            <!-- Pause Screen -->
            <div id="pauseScreen" class="screen hidden">
                <h2>SYSTEM PAUSED</h2>
                <div class="controls" style="flex-direction:column; gap:20px;">
                    <button id="resumeBtn" class="action-btn">RESUME</button>
                    <button id="restartFromPauseBtn">RESTART LEVEL</button>
                    <button id="quitBtn">QUIT TO MENU</button>
                </div>
            </div>
        </div>
        
        <div class="footer">
            <p style="margin:0; font-size:0.8rem;">Controls: Mouse / Touch / Arrows &nbsp;|&nbsp; P to Pause</p>
        </div>
    </div>

    <script>
        /**
         * BUBBLE BOUNCE PRO - ENGINE
         * High-performance Canvas Game
         * (c) 2025
         */

        // --- CONSTANTS & CONFIG ---
        const CONFIG = {
            LOGICAL_WIDTH: 800,
            LOGICAL_HEIGHT: 500,
            PADDLE: { WIDTH: 100, HEIGHT: 14, SPEED: 700 }, // Speed in px/sec
            BALL: { RADIUS: 8, SPEED_BASE: 380, MAX_SPEED: 800 },
            BUBBLE: { RADIUS: 22, ROWS_BASE: 3 },
            PARTICLES: { COUNT: 15, LIFE: 0.6, SPEED: 150 },
            COLORS: {
                PADDLE: '#00f2ff',
                BALL: '#ffffff',
                TEXT: '#ffffff'
            }
        };

        // --- GAME STATE ---
        const state = {
            score: 0,
            level: 1,
            lives: 3,
            paused: false,
            gameOver: false,
            soundOn: true,
            lastTime: 0,
            shake: 0,
            paddle: { x: 0, y: 0, width: 0 },
            balls: [],
            bubbles: [],
            powerUps: [],
            particles: [],
            keys: { left: false, right: false },
            activePowerUps: { widen: 0, slow: 0, multi: 0 },
            canvasOffset: { x: 0, y: 0, scale: 1 }
        };

        // --- ASSETS & UTIL ---
        const canvas = document.getElementById('gameCanvas');
        const ctx = canvas.getContext('2d', { alpha: false }); // Optimize
        
        // UI Elements
        const ui = {
            score: document.getElementById('score'),
            level: document.getElementById('level'),
            lives: document.getElementById('lives'),
            screens: {
                start: document.getElementById('startScreen'),
                level: document.getElementById('levelSelectScreen'),
                gameOver: document.getElementById('gameOverScreen'),
                pause: document.getElementById('pauseScreen')
            },
            finalScore: document.getElementById('finalScore'),
            scoreList: document.getElementById('scoreList'),
            gameOverTitle: document.getElementById('gameOverTitle'),
            soundBtn: document.getElementById('toggleSoundBtn')
        };

        // --- RESIZE LOGIC (LETTERBOXING) ---
        function resize() {
            const container = canvas.parentElement;
            const rect = container.getBoundingClientRect();
            
            // Set styles to fill container
            canvas.style.width = rect.width + 'px';
            canvas.style.height = rect.height + 'px';
            
            // Set internal resolution (High DPI)
            const dpr = window.devicePixelRatio || 1;
            canvas.width = rect.width * dpr;
            canvas.height = rect.height * dpr;
            
            // Calculate scale to fit LOGICAL size into PHYSICAL size
            // maintaining aspect ratio (Letterboxing 'contain' approach)
            const scaleX = canvas.width / CONFIG.LOGICAL_WIDTH;
            const scaleY = canvas.height / CONFIG.LOGICAL_HEIGHT;
            const scale = Math.min(scaleX, scaleY);
            
            state.canvasOffset.scale = scale;
            state.canvasOffset.x = (canvas.width - CONFIG.LOGICAL_WIDTH * scale) / 2;
            state.canvasOffset.y = (canvas.height - CONFIG.LOGICAL_HEIGHT * scale) / 2;
            
            // Apply Transform
            ctx.setTransform(scale, 0, 0, scale, state.canvasOffset.x, state.canvasOffset.y);
            
            // Need to redraw immediately to avoid black screen flicker
            if(state.lastTime) draw();
        }
        window.addEventListener('resize', resize);
        
        // --- CLASSES ---

        class Particle {
            constructor(x, y, color) {
                this.x = x;
                this.y = y;
                this.color = color;
                const angle = Math.random() * Math.PI * 2;
                const speed = Math.random() * CONFIG.PARTICLES.SPEED;
                this.dx = Math.cos(angle) * speed;
                this.dy = Math.sin(angle) * speed;
                this.life = 1.0;
                this.size = Math.random() * 3 + 1;
            }
            update(dt) {
                this.x += this.dx * dt;
                this.y += this.dy * dt;
                this.life -= dt / CONFIG.PARTICLES.LIFE;
            }
            draw(ctx) {
                ctx.globalAlpha = Math.max(0, this.life);
                ctx.fillStyle = this.color;
                ctx.beginPath();
                ctx.arc(this.x, this.y, this.size, 0, Math.PI * 2);
                ctx.fill();
                ctx.globalAlpha = 1.0;
            }
        }

        class Ball {
            constructor(x, y) {
                this.x = x;
                this.y = y;
                this.radius = CONFIG.BALL.RADIUS;
                const angle = -Math.PI / 2 + (Math.random() * 0.5 - 0.25);
                this.speed = CONFIG.BALL.SPEED_BASE + (state.level * 15); // Difficulty Scaling
                this.dx = Math.cos(angle) * this.speed;
                this.dy = Math.sin(angle) * this.speed;
                this.color = CONFIG.COLORS.BALL;
                this.trail = [];
            }
            
            update(dt) {
                const timeScale = state.activePowerUps.slow > 0 ? 0.5 : 1.0;
                const step = dt * timeScale;
                
                this.x += this.dx * step;
                this.y += this.dy * step;

                // Trail
                if (Math.random() > 0.6) {
                    this.trail.push({x: this.x, y: this.y, alpha: 0.4});
                    if (this.trail.length > 5) this.trail.shift();
                }

                // Walls
                if (this.x < this.radius) { this.x = this.radius; this.dx *= -1; }
                if (this.x > CONFIG.LOGICAL_WIDTH - this.radius) { this.x = CONFIG.LOGICAL_WIDTH - this.radius; this.dx *= -1; }
                if (this.y < this.radius) { this.y = this.radius; this.dy *= -1; }
            }

            draw(ctx) {
                // Trail
                this.trail.forEach(t => {
                    ctx.fillStyle = `rgba(255, 255, 255, ${t.alpha * 0.3})`;
                    ctx.beginPath();
                    ctx.arc(t.x, t.y, this.radius * 0.7, 0, Math.PI * 2);
                    ctx.fill();
                    t.alpha -= 0.05;
                });

                // Ball
                ctx.shadowBlur = 10;
                ctx.shadowColor = this.color;
                ctx.fillStyle = this.color;
                ctx.beginPath();
                ctx.arc(this.x, this.y, this.radius, 0, Math.PI * 2);
                ctx.fill();
                ctx.shadowBlur = 0;
            }
        }

        class Bubble {
            constructor(c, r, level) {
                const gap = 8;
                const diameter = CONFIG.BUBBLE.RADIUS * 2;
                const totalW = 12 * (diameter + gap); 
                const startX = (CONFIG.LOGICAL_WIDTH - totalW) / 2 + CONFIG.BUBBLE.RADIUS;
                
                this.x = startX + c * (diameter + gap);
                this.y = 70 + r * (diameter + gap);
                this.radius = CONFIG.BUBBLE.RADIUS;
                this.active = true;
                
                const rand = Math.random();
                this.type = 'normal';
                this.hits = 1; 
                this.maxHits = 1;
                this.color = '#ff5252';
                
                if (level > 1 && rand > 0.7) {
                    this.type = 'tough'; this.hits = 2; this.maxHits = 2; this.color = '#ffd740';
                }
                if (level > 2 && rand > 0.85) {
                    this.type = 'epic'; this.hits = 3; this.maxHits = 3; this.color = '#bd00ff';
                }

                this.powerUp = null;
                if (Math.random() > 0.92) {
                    const types = ['widen', 'slow', 'multi', 'life'];
                    this.powerUp = types[Math.floor(Math.random() * types.length)];
                }
            }

            draw(ctx) {
                if (!this.active) return;
                
                const grad = ctx.createRadialGradient(this.x - 5, this.y - 5, 2, this.x, this.y, this.radius);
                if (this.type === 'normal') { grad.addColorStop(0, '#ff8a80'); grad.addColorStop(1, '#d50000'); }
                else if (this.type === 'tough') { grad.addColorStop(0, '#ffff8d'); grad.addColorStop(1, '#ffab00'); }
                else { grad.addColorStop(0, '#e040fb'); grad.addColorStop(1, '#7c4dff'); }

                ctx.fillStyle = grad;
                ctx.shadowBlur = 8;
                ctx.shadowColor = this.color;
                ctx.beginPath();
                ctx.arc(this.x, this.y, this.radius, 0, Math.PI * 2);
                ctx.fill();
                ctx.shadowBlur = 0;

                ctx.fillStyle = 'rgba(255,255,255,0.4)';
                ctx.beginPath();
                ctx.arc(this.x - 7, this.y - 7, 5, 0, Math.PI*2);
                ctx.fill();

                if (this.powerUp) {
                    ctx.fillStyle = '#fff';
                    ctx.font = '10px Orbitron';
                    ctx.fillText('â˜…', this.x - 3, this.y + 3);
                }
                
                if (this.hits < this.maxHits) {
                    ctx.fillStyle = 'rgba(0,0,0,0.5)';
                    ctx.beginPath();
                    ctx.arc(this.x, this.y, 10, 0, Math.PI*2);
                    ctx.fill();
                }
            }
        }

        // --- CORE FUNCTIONS ---

        function init() {
            state.score = 0;
            state.lives = 3;
            state.level = 1;
            state.paused = false;
            state.gameOver = false;
            state.activePowerUps = { widen: 0, slow: 0, multi: 0 };
            
            resize();
            initLevel();
            updateStats();
            
            state.lastTime = performance.now();
            requestAnimationFrame(gameLoop);
        }

        function initLevel() {
            state.balls = [new Ball(CONFIG.LOGICAL_WIDTH / 2, CONFIG.LOGICAL_HEIGHT - 50)];
            state.paddle = {
                x: CONFIG.LOGICAL_WIDTH / 2 - CONFIG.PADDLE.WIDTH / 2,
                y: CONFIG.LOGICAL_HEIGHT - 30,
                width: CONFIG.PADDLE.WIDTH,
                height: CONFIG.PADDLE.HEIGHT
            };
            state.bubbles = [];
            state.powerUps = [];
            state.particles = [];
            state.activePowerUps = { widen: 0, slow: 0, multi: 0 };
            
            const rows = CONFIG.BUBBLE.ROWS_BASE + state.level;
            const cols = 12; 
            for (let r = 0; r < rows; r++) {
                for (let c = 0; c < cols; c++) {
                    state.bubbles.push(new Bubble(c, r, state.level));
                }
            }
            
            ui.screens.start.classList.add('hidden');
            ui.screens.level.classList.add('hidden');
            ui.screens.gameOver.classList.add('hidden');
            ui.screens.pause.classList.add('hidden');
        }

        function update(dt) {
            if (state.paused || state.gameOver) return;

            // Paddle
            if (state.keys.left) state.paddle.x -= CONFIG.PADDLE.SPEED * dt;
            if (state.keys.right) state.paddle.x += CONFIG.PADDLE.SPEED * dt;

            state.paddle.width = state.activePowerUps.widen > 0 ? 160 : 100;
            if (state.paddle.x < 0) state.paddle.x = 0;
            if (state.paddle.x + state.paddle.width > CONFIG.LOGICAL_WIDTH) 
                state.paddle.x = CONFIG.LOGICAL_WIDTH - state.paddle.width;

            // Timers
            if (state.activePowerUps.widen > 0) state.activePowerUps.widen -= dt;
            if (state.activePowerUps.slow > 0) state.activePowerUps.slow -= dt;

            // Particles
            for (let i = state.particles.length - 1; i >= 0; i--) {
                state.particles[i].update(dt);
                if (state.particles[i].life <= 0) state.particles.splice(i, 1);
            }

            // Powerups
            for (let i = state.powerUps.length - 1; i >= 0; i--) {
                const p = state.powerUps[i];
                p.y += p.dy * dt;
                p.angle += 2 * dt;

                if (p.y + p.radius >= state.paddle.y && 
                    p.y - p.radius <= state.paddle.y + state.paddle.height &&
                    p.x >= state.paddle.x && 
                    p.x <= state.paddle.x + state.paddle.width) {
                    
                    activatePowerUp(p.type);
                    state.powerUps.splice(i, 1);
                } else if (p.y > CONFIG.LOGICAL_HEIGHT) {
                    state.powerUps.splice(i, 1);
                }
            }

            // Balls
            let activeBalls = 0;
            for (let bIndex = state.balls.length - 1; bIndex >= 0; bIndex--) {
                const ball = state.balls[bIndex];
                ball.update(dt);

                // Paddle Collision
                if (ball.dy > 0 &&
                    ball.y + ball.radius >= state.paddle.y &&
                    ball.y - ball.radius <= state.paddle.y + state.paddle.height &&
                    ball.x >= state.paddle.x &&
                    ball.x <= state.paddle.x + state.paddle.width) {
                    
                    ball.y = state.paddle.y - ball.radius - 1;
                    const hitPoint = (ball.x - (state.paddle.x + state.paddle.width/2)) / (state.paddle.width/2);
                    const angle = hitPoint * (Math.PI / 3); 

                    const currentSpeed = Math.min(Math.sqrt(ball.dx*ball.dx + ball.dy*ball.dy) * 1.05, CONFIG.BALL.MAX_SPEED);
                    ball.dx = Math.sin(angle) * currentSpeed;
                    ball.dy = -Math.cos(angle) * currentSpeed;
                    
                    if(state.soundOn) {/* Optional: Synthetic sound could go here */}
                }

                // Bubble Collision
                let hitBubble = false;
                for (let i = state.bubbles.length - 1; i >= 0; i--) {
                    const bubble = state.bubbles[i];
                    if (!bubble.active) continue;

                    const dx = ball.x - bubble.x;
                    const dy = ball.y - bubble.y;
                    const dist = Math.sqrt(dx*dx + dy*dy);

                    if (dist < ball.radius + bubble.radius) {
                        const angle = Math.atan2(dy, dx);
                        if (Math.abs(dx) > Math.abs(dy)) ball.dx *= -1;
                        else ball.dy *= -1;

                        bubble.hits--;
                        if (bubble.hits <= 0) {
                            bubble.active = false;
                            state.score += (bubble.type === 'epic' ? 50 : bubble.type === 'tough' ? 20 : 10);
                            createExplosion(bubble.x, bubble.y, bubble.color);
                            if (bubble.powerUp) spawnPowerUp(bubble.x, bubble.y, bubble.powerUp);
                            state.shake = 5;
                        } else {
                            state.score += 5;
                        }
                        
                        updateStats();
                        hitBubble = true;
                        break; 
                    }
                }

                if (ball.y - ball.radius > CONFIG.LOGICAL_HEIGHT) {
                    state.balls.splice(bIndex, 1);
                } else {
                    activeBalls++;
                }
            }

            if (state.shake > 0) {
                state.shake -= dt * 30;
                if(state.shake < 0) state.shake = 0;
            }

            if (state.bubbles.every(b => !b.active)) {
                state.level++;
                if (state.level > 10) endGame(true);
                else { initLevel(); updateStats(); }
            }

            if (state.balls.length === 0) {
                state.lives--;
                updateStats();
                if (state.lives <= 0) endGame(false);
                else state.balls.push(new Ball(state.paddle.x + state.paddle.width/2, state.paddle.y - 20));
            }
        }

        function createExplosion(x, y, color) {
            for(let i=0; i<CONFIG.PARTICLES.COUNT; i++) {
                state.particles.push(new Particle(x, y, color));
            }
        }

        function spawnPowerUp(x, y, type) {
            state.powerUps.push({ x, y, type, dy: 100, radius: 12, angle: 0 });
        }

        function activatePowerUp(type) {
            state.score += 50;
            updateStats();
            switch(type) {
                case 'widen': state.activePowerUps.widen = 10; break;
                case 'slow': state.activePowerUps.slow = 8; break;
                case 'life': state.lives++; updateStats(); break;
                case 'multi': 
                    const len = state.balls.length;
                    for(let i=0; i<len; i++) {
                        const b = state.balls[i];
                        state.balls.push(new Ball(b.x, b.y));
                    }
                    if (state.balls.length > 50) state.balls.length = 50; 
                    break;
            }
        }

        function draw() {
            // Need to clear the ENTIRE physical canvas here.
            // We strip the transform temporarily.
            ctx.save();
            ctx.setTransform(1, 0, 0, 1, 0, 0); // Identity
            ctx.clearRect(0, 0, canvas.width, canvas.height); // Clear all
            
            // Draw background grid (optional)
            ctx.strokeStyle = 'rgba(255,255,255,0.03)';
            ctx.lineWidth = 1;
            // A simple grid could improve the "tech" look, but let's keep it clean as per request.
            
            ctx.restore(); // Restore letterboxing transform

            // Apply Shake
            if (state.shake > 0) {
                const dx = (Math.random() - 0.5) * state.shake;
                const dy = (Math.random() - 0.5) * state.shake;
                ctx.translate(dx, dy);
            }
            
            // Clip to logical area to prevent drawing outside in letterbox margins
            // (Optional, keeps it clean)
            ctx.beginPath();
            ctx.rect(0, 0, CONFIG.LOGICAL_WIDTH, CONFIG.LOGICAL_HEIGHT);
            ctx.clip();

            // Draw game props
            ctx.shadowBlur = 20;
            ctx.shadowColor = CONFIG.COLORS.PADDLE;
            ctx.fillStyle = CONFIG.COLORS.PADDLE;
            ctx.beginPath();
            if(ctx.roundRect) ctx.roundRect(state.paddle.x, state.paddle.y, state.paddle.width, state.paddle.height, 8);
            else ctx.rect(state.paddle.x, state.paddle.y, state.paddle.width, state.paddle.height);
            ctx.fill();
            ctx.shadowBlur = 0;
            
            state.bubbles.forEach(b => b.draw(ctx));

            state.powerUps.forEach(p => {
                ctx.save();
                ctx.translate(p.x, p.y);
                ctx.rotate(p.angle);
                ctx.shadowBlur = 10; ctx.shadowColor = '#fff'; ctx.fillStyle = '#fff';
                ctx.beginPath();
                for (let i = 0; i < 5; i++) {
                    ctx.lineTo(Math.cos((18 + i * 72) * Math.PI / 180) * p.radius, -Math.sin((18 + i * 72) * Math.PI / 180) * p.radius);
                    ctx.lineTo(Math.cos((54 + i * 72) * Math.PI / 180) * (p.radius / 2), -Math.sin((54 + i * 72) * Math.PI / 180) * (p.radius / 2));
                }
                ctx.fill();
                ctx.restore();
            });

            state.particles.forEach(p => p.draw(ctx));
            state.balls.forEach(b => b.draw(ctx));
        }

        function gameLoop(timestamp) {
            const dt = Math.min((timestamp - state.lastTime) / 1000, 0.1); 
            state.lastTime = timestamp;
            update(dt);
            draw();
            if (!state.gameOver) requestAnimationFrame(gameLoop);
        }

        function updateStats() {
            ui.score.textContent = state.score;
            ui.level.textContent = state.level;
            ui.lives.textContent = state.lives;
        }

        function endGame(win) {
            state.gameOver = true;
            ui.gameOverTitle.textContent = win ? "MISSION COMPLETE" : "SYSTEM FAILURE";
            ui.gameOverTitle.style.color = win ? "#00ff00" : "#ff0000";
            ui.finalScore.textContent = state.score;
            ui.screens.gameOver.classList.remove('hidden');
            loadScores();
        }

        // --- INPUT & CONTROLS ---
        
        window.addEventListener('keydown', e => {
            if (e.key === 'ArrowLeft') state.keys.left = true;
            if (e.key === 'ArrowRight') state.keys.right = true;
            if (e.key.toLowerCase() === 'p') togglePause();
        });
        window.addEventListener('keyup', e => {
            if (e.key === 'ArrowLeft') state.keys.left = false;
            if (e.key === 'ArrowRight') state.keys.right = false;
        });

        function handlePointerMove(e) {
            if (state.paused || state.gameOver) return;
            const rect = canvas.getBoundingClientRect();
            let clientX = e.clientX;
            if (e.touches && e.touches.length > 0) clientX = e.touches[0].clientX;
            
            // Calculate X in logical coordinates with letterboxing offset and scale
            const xPhysical = (clientX - rect.left) * (canvas.width / rect.width);
            const xLogical = (xPhysical - state.canvasOffset.x) / state.canvasOffset.scale;
            
            state.paddle.x = xLogical - state.paddle.width / 2;
        }

        canvas.addEventListener('mousemove', handlePointerMove);
        canvas.addEventListener('touchmove', handlePointerMove, {passive: false});

        document.getElementById('startBtn').onclick = () => {
            ui.screens.start.classList.add('hidden');
            ui.screens.level.classList.remove('hidden');
        };
        document.getElementById('backToStartBtn').onclick = () => {
            ui.screens.level.classList.add('hidden');
            ui.screens.start.classList.remove('hidden');
        };
        document.querySelectorAll('.level-btn').forEach(btn => {
            btn.onclick = () => {
                state.level = parseInt(btn.dataset.level);
                init();
            };
        });

        function togglePause() {
            if (state.gameOver) return;
            state.paused = !state.paused;
            if (state.paused) {
                ui.screens.pause.classList.remove('hidden');
            } else {
                ui.screens.pause.classList.add('hidden');
                state.lastTime = performance.now();
                requestAnimationFrame(gameLoop);
            }
        }
        
        document.getElementById('pauseBtn').onclick = togglePause;
        document.getElementById('resumeBtn').onclick = togglePause;
        document.getElementById('toggleSoundBtn').onclick = function() {
            state.soundOn = !state.soundOn;
            this.textContent = state.soundOn ? "SOUND: ON" : "SOUND: OFF";
        };
        
        document.getElementById('restartBtn').onclick = () => {
            ui.screens.gameOver.classList.add('hidden');
            state.level = 1;
            init();
        };
        document.getElementById('restartFromPauseBtn').onclick = () => {
             ui.screens.pause.classList.add('hidden');
             init();
        };
        document.getElementById('menuBtn').onclick = () => {
             ui.screens.gameOver.classList.add('hidden');
             ui.screens.start.classList.remove('hidden');
        };
        document.getElementById('quitBtn').onclick = () => {
             ui.screens.pause.classList.add('hidden');
             state.gameOver = true;
             ui.screens.start.classList.remove('hidden');
        };

        function loadScores() {
            const list = JSON.parse(localStorage.getItem('bounceScores') || '[]');
            ui.scoreList.innerHTML = list
                .sort((a,b) => b.score - a.score)
                .slice(0, 5)
                .map(s => `<li><span>${s.name}</span><span>${s.score}</span></li>`)
                .join('');
        }
        document.getElementById('saveScoreBtn').onclick = () => {
            const name = document.getElementById('playerName').value || 'Pilot';
            const list = JSON.parse(localStorage.getItem('bounceScores') || '[]');
            list.push({name, score: state.score});
            localStorage.setItem('bounceScores', JSON.stringify(list));
            loadScores();
            document.getElementById('saveScoreBtn').disabled = true;
            document.getElementById('saveScoreBtn').textContent = 'SAVED';
        };

        resize();
        
        // Polyfill
        if (!ctx.roundRect) ctx.roundRect = function(x, y, w, h, r) { this.rect(x,y,w,h); }; // Fallback

    </script>
</body>
</html>